package lsd.jdbc

import lsd.LSDStatementAPI
import lsd.core.parser.operations.lsd.IsTrue
import lsd.core.parser.operations.Operation
import lsd.core.parser.operations.StandardSQL
import lsd.core.parser.operations.lsd.SelectLSD
import lsd.core.parser.operations.lsd.UpdateLSD
import lsd.util.LSDException
import java.sql.*

// TODO this class needs to be rewritten to work like PreparedStatement
//  as it stands, it doesn't work properly

internal open class LSDStatement(
    protected val conn: LSDConnection,
    resultSetType: Int,
    resultSetConcurrency: Int,
    resultSetHoldability: Int
) : LSDStatementAPI {

    private var activeOp = conn.parser.parse("")
    private var activeStatement = conn.dbConn.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability)
    private var activeResultSet = activeStatement.resultSet
    protected var closed = false

    override fun <T : Any?> unwrap(iface: Class<T>?): T {
        if (iface!!.isAssignableFrom(javaClass))
            return iface.cast(this)

        throw LSDException("Cannot unwrap to " + iface.name)
    }

    override fun isWrapperFor(iface: Class<*>?): Boolean {
        return iface!!.isAssignableFrom(javaClass)
    }

    override fun close() {
        if (!closed) {
            closed = true
            activeStatement.close()
        }
    }

    /**
     * To be used by users who wish to execute queries that return result sets (i.e. SELECT)
     *
     * If another result set exists for this statement, it will be closed
     * (even if this statement fails).
     *
     * @param sql the SQL statement to execute
     * @return the result set
     */
    override fun executeQuery(sql: String?): ResultSet {
        check(!closed) { throw LSDException("Statement is closed.") }

        when(val op = conn.parser.parse(sql)) {
            is IsTrue ->
                throw LSDException("'IS-TRUE' does not return a result set, this is an incorrect usage of the API.")
            is SelectLSD -> {
                val fut = LSDFuture(op.future, activeOp.query)
                this.conn.readMap[fut.id] = fut
                activeOp = op
                activeResultSet = LSDResultSet(fut)
            }
            is StandardSQL -> activeResultSet = activeStatement.executeQuery(activeOp.query)
            else -> throw LSDException("Statement isn't a query.")
        }
        return activeResultSet
    }

    /**
     * To be used by users who wish to execute queries that do not return result sets (i.e. UPDATE, CREATE, etc)
     *
     * If another result set exists for this statement, it will be closed
     * (even if this statement fails).
     *
     * If auto commit is on, this statement will be committed.
     * If the statement is a DDL statement (create, drop, alter) and does not
     * throw an exception, the current transaction (if any) is committed after
     * executing the statement.
     *
     * @param sql the SQL statement
     * @return the update count (number of affected rows by a DML statement or
     *         other statement able to return number of rows, or 0 if no rows
     *         were affected or the statement returned nothing, or
     *         {@link #SUCCESS_NO_INFO} if number of rows is too large for the
     *         {@code int} data type)
     *         If an IS-TRUE is executed, returns 0 if condition
     * @throws LSDException if a database error occurred or a
     *         select statement was executed
     * @see #executeLargeUpdate(String)
     */
    override fun executeUpdate(sql: String?): Int {
        return executeUpdate(sql, autoGeneratedKeys = Statement.NO_GENERATED_KEYS)
    }

    /**
     * To be used by users who wish to execute queries that do not return result sets (i.e. UPDATE, CREATE, etc)
     *
     * @param sql the SQL statement
     * @param autoGeneratedKeys
     *            {@link Statement#RETURN_GENERATED_KEYS} if generated keys should
     *            be available for retrieval, {@link Statement#NO_GENERATED_KEYS} if
     *            generated keys should not be available
     * @return the update count (number of affected rows by a DML statement or
     *         other statement able to return number of rows, or 0 if no rows
     *         were affected or the statement returned nothing, or
     *         {@link #SUCCESS_NO_INFO} if number of rows is too large for the
     *         {@code int} data type)
     * @throws LSDException if a database error occurred or a
     *         select statement was executed
     * @see #executeLargeUpdate(String, int)
     */
    override fun executeUpdate(sql: String?, autoGeneratedKeys: Int): Int {
        check(!closed) { throw LSDException("Statement is closed.") }

        val op = conn.parser.parse(sql)
        activeOp = op

        return when (op) {
            is IsTrue -> {
                conn.operations.add(op)
                Statement.SUCCESS_NO_INFO
            }
            is UpdateLSD -> { // LSD updates
                conn.operations.add(op)
                Statement.SUCCESS_NO_INFO // This can be any value
            }
            is StandardSQL -> { // Standard SQL updates
                activeStatement = createStatement()
                activeStatement.executeUpdate(activeOp.query, autoGeneratedKeys)
            }
            else -> throw LSDException("Statement isn't an update.")
        }
    }

    /**
     * To be used by users who wish to execute queries that do not return result sets (i.e. UPDATE, CREATE, etc)
     *
     * @param sql the SQL statement
     * @param columnIndexes
     *            an array of column indexes indicating the columns with generated
     *            keys that should be returned from the inserted row
     * @return the update count (number of affected rows by a DML statement or
     *         other statement able to return number of rows, or 0 if no rows
     *         were affected or the statement returned nothing)
     * @throws LSDException if a database error occurred or a
     *         select statement was executed
     */
    override fun executeUpdate(sql: String?, columnIndexes: IntArray?): Int {
        check(!closed) { throw LSDException("Statement is closed.") }

        val op = conn.parser.parse(sql)
        activeOp = op

        return when (op) {
            is IsTrue -> {
                conn.operations.add(op)

                Statement.SUCCESS_NO_INFO
            }
            is UpdateLSD -> { // LSD updates
                conn.operations.add(op)

                Statement.SUCCESS_NO_INFO // This can be any value
            }
            is StandardSQL -> { // Standard SQL updates
                activeStatement = createStatement()
                activeStatement.executeUpdate(activeOp.query, columnIndexes)
            }
            else -> throw LSDException("Statement isn't an update.")
        }
    }

    /**
     * To be used by users who wish to execute queries that do not return result sets (i.e. UPDATE, CREATE, etc)
     *
     * @param sql the SQL statement
     * @param columnNames
     *            an array of column names indicating the columns with generated
     *            keys that should be returned from the inserted row
     * @return the update count (number of affected rows by a DML statement or
     *         other statement able to return number of rows, or 0 if no rows
     *         were affected or the statement returned nothing, or
     *         {@link #SUCCESS_NO_INFO} if number of rows is too large for the
     *         {@code int} data type)
     * @throws LSDException if a database error occurred or a
     *         select statement was executed
     * @see #executeLargeUpdate(String, String[])
     */
    override fun executeUpdate(sql: String?, columnNames: Array<out String>?): Int {
        check(!closed) { throw LSDException("Statement is closed.") }

        val op = conn.parser.parse(sql)
        activeOp = op

        return when (op) {
            is IsTrue -> {
                conn.operations.add(op)

                Statement.SUCCESS_NO_INFO
            }
            is UpdateLSD -> { // LSD updates
                conn.operations.add(op)

                Statement.SUCCESS_NO_INFO // This can be any value
            }
            is StandardSQL -> { // Standard SQL updates
                activeStatement = createStatement()
                activeStatement.executeUpdate(activeOp.query, columnNames)
            }
            else -> throw LSDException("Statement isn't an update.")
        }
    }

    override fun getMaxFieldSize(): Int {
        return activeStatement.maxFieldSize
    }

    override fun setMaxFieldSize(max: Int) {
        activeStatement.maxFieldSize = max
    }

    override fun getMaxRows(): Int {
        return activeStatement.maxRows
    }

    override fun setMaxRows(max: Int) {
        activeStatement.maxRows = max
    }

    override fun setEscapeProcessing(enable: Boolean) {
        activeStatement.setEscapeProcessing(enable)
    }

    override fun getQueryTimeout(): Int {
        return activeStatement.queryTimeout
    }

    override fun setQueryTimeout(seconds: Int) {
        activeStatement.queryTimeout = seconds
    }

    override fun cancel() {
        activeStatement.cancel()
    }

    override fun getWarnings(): SQLWarning {
        return activeStatement.warnings
    }

    override fun clearWarnings() {
        activeStatement.clearWarnings()
    }

    override fun setCursorName(name: String?) {
        activeStatement.setCursorName(name)
    }

    /**
     * Executes a statement and returns type of its result.
     *
     * @param sql the SQL statement
     * @return true if result is a result set, false otherwise
     * @throws LSDException if a database error occurred or a
     *         select statement was executed
     */
    override fun execute(sql: String?): Boolean {
        return execute(sql, autoGeneratedKeys = Statement.NO_GENERATED_KEYS)
    }

    /**
     * Executes a statement and returns type of its result.
     *
     * @param sql the SQL statement
     * @param autoGeneratedKeys
     *            {@link Statement#RETURN_GENERATED_KEYS} if generated keys should
     *            be available for retrieval, {@link Statement#NO_GENERATED_KEYS} if
     *            generated keys should not be available
     * @return true if result is a result set, false otherwise
     * @throws LSDException if a database error occurred or a
     *         select statement was executed
     */
    override fun execute(sql: String?, autoGeneratedKeys: Int): Boolean {
        check(!closed) { throw LSDException("Statement is closed.") }

        closeForNextExecution()

        activeOp.generatedKeys = autoGeneratedKeys

        activeStatement = createStatement()
        return activeStatement.execute(activeOp.query, autoGeneratedKeys)
    }

    /**
     * Executes a statement and returns type of its result.
     *
     * @param sql the SQL statement
     * @param columnIndexes
     *            an array of column indexes indicating the columns with generated
     *            keys that should be returned from the inserted row
     * @return true if result is a result set, false otherwise
     * @throws LSDException if a database error occurred or a
     *         select statement was executed
     */
    override fun execute(sql: String?, columnIndexes: IntArray?): Boolean {
        check(!closed) { throw LSDException("Statement is closed.") }

        closeForNextExecution()

        activeOp = conn.parser.parse(sql)
        activeOp.columnIndexes = columnIndexes

        activeStatement = createStatement()

        return activeStatement.execute(activeOp.query, columnIndexes)
    }

    /**
     * Executes a statement and returns type of its result.
     *
     * @param sql the SQL statement
     * @param columnNames
     *            an array of column names indicating the columns with generated
     *            keys that should be returned from the inserted row
     * @return true if result is a result set, false otherwise
     * @throws LSDException if a database error occurred or a
     *         select statement was executed
     */
    override fun execute(sql: String?, columnNames: Array<out String>?): Boolean {
        check(!closed) { throw LSDException("Statement is closed.") }

        closeForNextExecution()

        activeOp = conn.parser.parse(sql)
        activeOp.columnNames = columnNames

        activeStatement = createStatement()

        return activeStatement.execute(activeOp.query, columnNames)
    }

    override fun getResultSet(): ResultSet {
        return activeResultSet
    }

    override fun getUpdateCount(): Int {
        return activeStatement.updateCount
    }

    override fun getMoreResults(): Boolean {
        return getMoreResults(Statement.CLOSE_ALL_RESULTS)
    }

    override fun getMoreResults(current: Int): Boolean {
        return activeStatement.getMoreResults(current)
    }

    override fun setFetchDirection(direction: Int) {
        activeStatement.fetchDirection = direction
    }

    override fun getFetchDirection(): Int {
        return activeStatement.fetchDirection
    }

    override fun setFetchSize(rows: Int) {
        activeStatement.fetchSize = rows
    }

    override fun getFetchSize(): Int {
        return activeStatement.fetchSize
    }

    override fun getResultSetConcurrency(): Int {
        return activeStatement.resultSetConcurrency
    }

    override fun getResultSetType(): Int {
        return activeStatement.resultSetType
    }

    /**
     * Adds a statement to the batch.
     *
     * @param sql the SQL statement
     */
    override fun addBatch(sql: String?) {
        activeStatement.addBatch(sql)
    }

    /**
     * Clears the batch.
     */
    override fun clearBatch() {
        activeStatement.clearBatch()
    }

    /**
     * Executes the batch.
     * If one of the batched statements fails, this database will continue.
     *
     * @return the array of update counts
     * @see #executeLargeBatch()
     */
    override fun executeBatch(): IntArray {
        return activeStatement.executeBatch()
    }

    override fun getConnection(): Connection {
        return conn
    }

    override fun getGeneratedKeys(): ResultSet {
        return activeStatement.generatedKeys
    }

    override fun getResultSetHoldability(): Int {
        return activeStatement.resultSetHoldability
    }

    override fun isClosed(): Boolean {
        return activeStatement.isClosed && !closed
    }

    override fun setPoolable(poolable: Boolean) {
        activeStatement.isPoolable = poolable
    }

    override fun isPoolable(): Boolean {
        return activeStatement.isPoolable
    }

    override fun closeOnCompletion() {
        activeStatement.closeOnCompletion()
    }

    override fun isCloseOnCompletion(): Boolean {
        return activeStatement.isCloseOnCompletion
    }

    protected fun closeForNextExecution() {
        // Every statement execution clears any previous warnings.
        clearWarnings()

        // Close any existing result sets associated with this statement.
        synchronized(this) {
            if (activeStatement.resultSet != null)
                activeStatement.resultSet.close()
            if (activeStatement.generatedKeys != null)
                activeStatement.generatedKeys.close()
        }
    }

    private fun createStatement(): Statement {
        return conn.dbConn.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability)
    }
}