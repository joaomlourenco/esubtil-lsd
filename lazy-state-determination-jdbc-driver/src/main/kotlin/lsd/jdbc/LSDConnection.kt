package lsd.jdbc

import lsd.core.parser.Parser
import lsd.core.parser.operations.lsd.*
import lsd.util.LSDException
import java.sql.*
import java.util.*
import java.util.concurrent.Executor
import kotlin.collections.HashMap

class LSDConnection(url: String, props: Properties) : Connection {

    private var closed = false // if connection is open

    // This is the connection for regular queries, to be used by the client
    internal val dbConn = createUnderlyingConn(url, props)

    internal val operations = LinkedList<LSDOperation>()
    internal val readMap = HashMap<String, LSDFuture>() // Map<Future.ID, Future>

    internal var parser = Parser() // To parse instructions

    override fun <T : Any?> unwrap(iface: Class<T>?): T {
        if (iface!!.isAssignableFrom(javaClass))
            return iface.cast(this)

        throw LSDException("Cannot unwrap to " + iface.name)
    }

    override fun isWrapperFor(iface: Class<*>?): Boolean {
        return iface!!.isAssignableFrom(javaClass)
    }

    override fun close() {
        if (!closed) {
            this.closed = true
            operations.clear()
            readMap.clear()
            dbConn.close()
        }
    }

    override fun createStatement(): Statement {
        return createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)
    }

    override fun createStatement(resultSetType: Int, resultSetConcurrency: Int): Statement {
        return createStatement(resultSetType, resultSetConcurrency, holdability)
    }

    override fun createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): Statement {
        check(!closed) { throw LSDException("Connection is closed.") }
        return LSDStatement(this, resultSetType, resultSetConcurrency, resultSetHoldability)
    }

    override fun prepareStatement(sql: String?): PreparedStatement {
        return prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)
    }

    override fun prepareStatement(sql: String?, resultSetType: Int, resultSetConcurrency: Int): PreparedStatement {
        return prepareStatement(sql, resultSetType, resultSetConcurrency, holdability)
    }

    override fun prepareStatement(
        sql: String?,
        resultSetType: Int,
        resultSetConcurrency: Int,
        resultSetHoldability: Int
    ): PreparedStatement {
        check(!closed) { throw LSDException("Connection is closed.") }

        return LSDPreparedStatement(this, sql, resultSetType, resultSetConcurrency, resultSetHoldability)
    }

    override fun prepareStatement(sql: String?, autoGeneratedKeys: Int): PreparedStatement {
        check(!closed) { throw LSDException("Connection is closed.") }

        return if (autoGeneratedKeys != Statement.RETURN_GENERATED_KEYS) {
            prepareStatement(sql)
        } else prepareStatement(sql, columnNames = null)
    }

    override fun prepareStatement(sql: String?, columnIndexes: IntArray?): PreparedStatement {
        check(!closed) { throw LSDException("Connection is closed.") }

        if (columnIndexes != null && columnIndexes.isEmpty()) {
            prepareStatement(sql)
        }

        throw LSDException("Returning autogenerated keys is not supported.")
    }

    override fun prepareStatement(sql: String?, columnNames: Array<out String>?): PreparedStatement {
        check(!closed) { throw LSDException("Connection is closed.") }

        if (columnNames != null && columnNames.isEmpty()) {
            return prepareStatement(sql)
        }

        return LSDPreparedStatement(
            this,
            sql,
            ResultSet.TYPE_FORWARD_ONLY,
            ResultSet.CONCUR_READ_ONLY, holdability
        )
    }

    override fun prepareCall(sql: String?): CallableStatement {
        check(!closed) { throw LSDException("Connection is closed.") }
        return prepareCall(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)
    }

    override fun prepareCall(sql: String?, resultSetType: Int, resultSetConcurrency: Int): CallableStatement {
        check(!closed) { throw LSDException("Connection is closed.") }
        return prepareCall(sql, resultSetType, resultSetConcurrency, holdability)
    }

    override fun prepareCall(
        sql: String?,
        resultSetType: Int,
        resultSetConcurrency: Int,
        resultSetHoldability: Int
    ): CallableStatement {
        throw LSDException("Unsupported CallableStatements")
    }

    override fun nativeSQL(sql: String?): String {
        check(!closed) { throw LSDException("Connection is closed.") }
        return dbConn.nativeSQL(sql)
    }

    override fun setAutoCommit(autoCommit: Boolean) {
        check(!closed) { throw LSDException("Connection is closed.") }
        dbConn.autoCommit = autoCommit
    }

    override fun getAutoCommit(): Boolean {
        check(!closed) { throw LSDException("Connection is closed.") }
        return dbConn.autoCommit
    }

    override fun commit() {
        check(!closed) { throw LSDException("Connection is closed.") }

        if (autoCommit) {
            throw LSDException("Cannot commit when autoCommit is enabled.")
        }

        // Lock connection
        synchronized(this) {
            for (op in operations) {
                when (op) {
                    is SelectLSD -> {
                        // resolve query futures
                        prepareForExecution(op)

                        // update readMap
                        val future = readMap[op.future]!!
                        future.query = op.activeQuery
                        future.resolve(this)
                    }
                    is IsTrue -> {
                        prepareForExecution(op)
                        if (!op.evaluate()) {
                            dbConn.rollback()
                            throw LSDException("'${op.activeQuery}' evaluated to false!")
                        }
                    }
                    is UpdateLSD, is InsertLSD -> {
                        prepareForExecution(op)
                        dbConn.prepareStatement(op.activeQuery).executeUpdate()
                    }
                    is IFLSD -> {
                        prepareForExecution(op)
                        // prepare statement and immediately execute it, parameters should already be set
                        dbConn.prepareStatement(parser.convert(op.resolve(this))).executeUpdate()

                    }
                    else -> {
                        dbConn.rollback()
                        throw LSDException("Operation ${op.javaClass} not recognized!")
                    }
                }
            }

            // Commit on underlying connection
            dbConn.commit()

            // Clear all
            readMap.clear()
            operations.clear()
        }
    }

    override fun rollback() {
        check(!closed) { throw LSDException("Connection is closed.") }
        operations.clear()
        readMap.clear()
        dbConn.rollback()
    }

    override fun rollback(savepoint: Savepoint?) {
        check(!closed) { throw LSDException("Connection is closed.") }
        dbConn.rollback(savepoint)
    }

    override fun isClosed(): Boolean {
        return closed
    }

    override fun getMetaData(): DatabaseMetaData {
        return dbConn.metaData
    }

    override fun setReadOnly(readOnly: Boolean) {
        dbConn.isReadOnly = readOnly
    }

    override fun isReadOnly(): Boolean {
        return dbConn.isReadOnly
    }

    override fun setCatalog(catalog: String?) {
        dbConn.catalog = catalog
    }

    override fun getCatalog(): String {
        return dbConn.catalog
    }

    override fun setTransactionIsolation(level: Int) {
        dbConn.transactionIsolation = level
    }

    override fun getTransactionIsolation(): Int {
        return dbConn.transactionIsolation
    }

    override fun getWarnings(): SQLWarning {
        return dbConn.warnings
    }

    override fun clearWarnings() {
        dbConn.clearWarnings()
    }

    override fun getTypeMap(): MutableMap<String, Class<*>> {
        return dbConn.typeMap
    }

    override fun setTypeMap(map: MutableMap<String, Class<*>>?) {
        dbConn.typeMap = map
    }

    override fun setHoldability(holdability: Int) {
        dbConn.holdability = holdability
    }

    override fun getHoldability(): Int {
        return dbConn.holdability
    }

    override fun setSavepoint(): Savepoint {
        return dbConn.setSavepoint()
    }

    override fun setSavepoint(name: String?): Savepoint {
        return dbConn.setSavepoint(name)
    }

    override fun releaseSavepoint(savepoint: Savepoint?) {
        dbConn.releaseSavepoint(savepoint)
    }

    override fun createClob(): Clob {
        return dbConn.createClob()
    }

    override fun createBlob(): Blob {
        return dbConn.createBlob()
    }

    override fun createNClob(): NClob {
        return dbConn.createNClob()
    }

    override fun createSQLXML(): SQLXML {
        return dbConn.createSQLXML()
    }

    override fun isValid(timeout: Int): Boolean {
        return dbConn.isValid(timeout)
    }

    override fun setClientInfo(name: String?, value: String?) {
        dbConn.setClientInfo(name, value)
    }

    override fun setClientInfo(properties: Properties?) {
        dbConn.clientInfo = properties
    }

    override fun getClientInfo(name: String?): String {
        return dbConn.getClientInfo(name)
    }

    override fun getClientInfo(): Properties {
        return dbConn.clientInfo
    }

    override fun createArrayOf(typeName: String?, elements: Array<out Any>?): java.sql.Array {
        check(!closed) { throw LSDException("Connection is closed.") }
        return dbConn.createArrayOf(typeName, elements)
    }

    override fun createStruct(typeName: String?, attributes: Array<out Any>?): Struct {
        check(!closed) { throw LSDException("Connection is closed.") }
        return dbConn.createStruct(typeName, attributes)
    }

    override fun setSchema(schema: String?) {
        dbConn.schema = schema
    }

    override fun getSchema(): String {
        return dbConn.schema
    }

    override fun abort(executor: Executor?) {
        check(!closed) { throw LSDException("Connection is closed.") }
        dbConn.abort(executor)
    }

    override fun setNetworkTimeout(executor: Executor?, milliseconds: Int) {
        dbConn.setNetworkTimeout(executor, milliseconds)
    }

    override fun getNetworkTimeout(): Int {
        return dbConn.networkTimeout
    }

    /**
     * Create connection for underlying database
     * @param url the connection string
     * @param props the properties of the connection
     * @return connection for underlying database
     */
    private fun createUnderlyingConn(url: String, props: Properties): Connection {
        return DriverManager.getConnection(url, props)
    }

    /**
     * Prepare query to be sent to database by resolving its futures.
     * @param op the operation
     */
    private fun prepareForExecution(op: LSDOperation) {
        val pair = parser.resolveFutures(op.activeQuery)
        op.activeQuery = pair.first
        for (i in pair.second.indices) {
            op.parameters[i] = readMap[pair.second[i]]!!.result
        }

        op.prepareForLSDExecution()
    }
}